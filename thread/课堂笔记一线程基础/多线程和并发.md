# 线程概念

## 线程组

ThreadGroup的提出是为了方便线程的管理，通过它可以批量设定一组线程的属性，比如setDaemon，设置未处理异常的处理方法，设置统一的安全策略等等；也可以通过线程组方便的获取线程的一些信息，**尽量不要使用，会带来线程安全问题**

![image-20201012222542868](D:\学习\动脑\多线程和并发\多线程和并发\img\image-20201012222542868.png)

## 启动线程

启动线程的方式只有一种：new Thread().start()

Runnable也是？错。Runnable只是Thread要执行的逻辑

Callable<T> FuturaTask也是Thread要执行的逻辑，只是封装了获取结果的功能

![image-20201012222736259](D:\学习\动脑\多线程和并发\多线程和并发\img\image-20201012222736259.png)

## 终止线程-Stop

![image-20201012222800158](D:\学习\动脑\多线程和并发\多线程和并发\img\image-20201012222800158.png)

![image-20201012222810589](D:\学习\动脑\多线程和并发\多线程和并发\img\image-20201012222810589.png)

理想输出：i=0 j=0

程序 执行结果：i=1 j=0

没有保证同步结果代码块里面的数据的一致性，破坏了线程安全

Stop：但是可能导致线程安全问题，JDK不建议使用

Destroy：JDK未实现该方法。

## interrupt

- interrupt方法并不会中断线程，只是打上中断标志
- 如果目标线程在调用wait()、wait（long）方法、join（）、join（long，int)、join（long，int）、sleep（long）或sleep（long，int）等方法后处于WAITING、Timed Waiting状态时，该线程被调用interrupt方法后，线程的WAITING、Timed Waiting状态将被清楚，并抛出InterruptedException异常
- park（）、parkNanos方法执行后，线程也处于WAITING、Timed Waiting，也会被唤醒，但是不会抛异常，且有很诡异的情况发生
- 如果目标线程是被I/O或者NIO中Channle所阻塞，同样，I/O操作会被中断或者返回特殊异常值。达到终止线程的目的
- 如果以上条件都不满足，则会设置此线程的中断状态

**正确的线程中止-interrupt**

![image-20201012223649278](D:\学习\动脑\多线程和并发\多线程和并发\img\image-20201012223649278.png)

此时线程被调用interrupt方法后，该线程的**中断状态将被清除**，抛出InterruptedException异常。



## daemon线程：主线程结束，进程就结束了吗？

- 守护线程：是指在程序运行的时候在后台提供一种通用服务的线程，进程结束时，会杀死所有的守护线程
- 用户线程：非守护线程就是用户线程
- 进程结束：没有非守护线程换在运行时，进程结束

**注意：**

- thread.setDaemon(true)必须在thread.start()之前设置，否则会跑出一个illegalThreadStateException异常。你不能把正在运行的常规线程设置为守护线程
- 在Daemon线程中产生的新线程也是Daemon的
- 守护线程应该永远也不会访问固有资源，如文件、数据库，因为它会在任何时候甚至在一个操作的中间发生中断

# 线程状态

## 线程6种状态

6个状态定义：java.lang.Thread.State

- New：尚未启动的线程的线程状态
- Runnable：可运行线程的线程状态，等待CPU调度
- Blocked：线程阻塞等待监视器锁定的线程状态，处于synchronized同步代码块或方法中被阻塞
- Waiting：线程等待的线程状态，不带timeout参数的方式调用Object.wait、Thread.join、LockSupport.park
- Time Waiting：具有指定等待时间的等待线程的线程状态。下列待超时的方式：Thread.sleep，Ojbect.waiting,Thread.join,LockSupport.parkNanos,LockSupport.partUntil
- Terminated：终止线程的线程状态。线程正常完成执行或者出现异常

![image-20201012224837612](D:\学习\动脑\多线程和并发\多线程和并发\img\image-20201012224837612.png)

## 正确的线程中止-标志位

代码逻辑中，增加一个判断，用来控制线程执行的中止。

![image-20201012225323782](D:\学习\动脑\多线程和并发\多线程和并发\img\image-20201012225323782.png)



# 线程间通信

## 通信方式

思考：同事之间是如何协作的



数据交互：

- 文件共享
- 网络共享
- 共享变量



线程间协作：

- jdk提供的线程协调API，例如：suspend/resume、wait/notify,park/unpark

## 文件共享

![image-20201012225525818](D:\学习\动脑\多线程和并发\多线程和并发\img\image-20201012225525818.png)

![image-20201012225533815](D:\学习\动脑\多线程和并发\多线程和并发\img\image-20201012225533815.png)

## 变量共享

![image-20201012225546931](D:\学习\动脑\多线程和并发\多线程和并发\img\image-20201012225546931.png)

![image-20201012225554005](D:\学习\动脑\多线程和并发\多线程和并发\img\image-20201012225554005.png)

## 线程协作-场景

示例：小朋友去买冰激凌，没有冰激凌，就等着。店员发现没有冰激凌，就做了一个，通知小朋友

![image-20201012225710846](D:\学习\动脑\多线程和并发\多线程和并发\img\image-20201012225710846.png)

这是多线程协作的典型场景：生产者-消费者模型。（线程阻塞、线程唤醒）

JDK中对于需要多线程协作完成某一项任务的场景，提供了对应API支持

## API-被弃用的suspend和resume

作用：调用suspend挂起目标线程，通过resume可以恢复线程执行。

![image-20201012225914460](D:\学习\动脑\多线程和并发\多线程和并发\img\image-20201012225914460.png)

被弃用的主要原因是，**容易写出死锁的代码**

## suspend/resume-死锁实例1

**在同步代码中使用**

![image-20201012230013909](D:\学习\动脑\多线程和并发\多线程和并发\img\image-20201012230013909.png)

## suspend/resume-死锁实例2	

**suspend比resume后执行时，会出现死锁**

![image-20201012230057033](D:\学习\动脑\多线程和并发\多线程和并发\img\image-20201012230057033.png)

## wait/notify机制

wait方法导致当前线程等待，加入该对象的等待集合中，并且放弃当前持有的对象锁。notify/notifyAll方法唤醒一个或所有正在等待这个对象锁的线程

**注意一：**
虽然会wait自动解锁，但是对于**顺序有要求**，如果在notify被调用之后，才开始wait方法的调用，线程会永远处于WAITING状态

**注意二：**

这些方法只能由同一个对象锁的持有者线程调用，也就是写在同步代码块里面，否则会抛出IllegalMonitorStateException异常

## wait/notify-示例代码

![image-20201012230506396](D:\学习\动脑\多线程和并发\多线程和并发\img\image-20201012230506396.png)

## wait/notify死锁示例

notify比wait后执行时，会出现死锁

![image-20201012230548916](D:\学习\动脑\多线程和并发\多线程和并发\img\image-20201012230548916.png)

## park/unpark机制

![image-20201018151736112](D:\学习\动脑\多线程和并发\多线程和并发\img\image-20201018151736112.png)

线程调用park则等待“许可”，unpark方法为指定线程提供“许可“

- 调用unpark之后，再调用park，线程会直接运行
- 提前调用unpark不叠加，连续多次调用unpark后，第一次调用park后会拿到“许可”直接运行，后续调用会进入等待

### park/unpark-示例代码

![image-20201018151941778](D:\学习\动脑\多线程和并发\多线程和并发\img\image-20201018151941778.png)

### park/unpark-死锁实例

**在同步代码块中使用park/unpark，容易出现死锁**

![image-20201018152044187](D:\学习\动脑\多线程和并发\多线程和并发\img\image-20201018152044187.png)

## 总结

![image-20201018152054156](D:\学习\动脑\多线程和并发\多线程和并发\img\image-20201018152054156.png)

## 伪唤醒

之前代码中用if语句来判断，是否进入等待状态，这样的做法是错误的！

官方建议**应该在循环中检查等待条件**，原因是处于等待状态的线程可能会收到**错误警报和伪唤醒**，如果不在循环中检查等待条件，程序 就会在没有满足结束条件的情况下退出。



**伪唤醒**是指线程并非因为notify、notifyall、unpark等api调用而意外唤醒，是更底层原因导致的。

![image-20201018152438628](D:\学习\动脑\多线程和并发\多线程和并发\img\image-20201018152438628.png)