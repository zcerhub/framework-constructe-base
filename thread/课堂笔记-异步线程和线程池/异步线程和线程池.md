# 多线程基础知识

## 线程核心概念

- 线程和进程有区别？CPU 内存 IO

- 进程=加载上下文+执行流程+保存上下文  性能上的消耗

  线程=CPU执行

- 进程属于资源分配最小单位，线程属于执行任务的最小单位

## Thread终止

## Thread状态

6个

线程比喻成一辆去幼儿园的车

New，Runnable，停下，TERMINATED

停下：交通拥挤，Block

​		  十字路口，等红绿灯  TimeWaiting

​			半路车坏了，Waiting

## Thread间通信

4种：文件共享、网络共享、变量共享、JDK线程协调API

JDK线程协调API：suspend/resume 	wait/notify  park/unpark

弥补录播中的问题：park/unpark interupted

伪唤醒 while（）



面试题：Callable Runnable的区别是什么？

**区别**

- Callable Runnable都是任务执行接口，Callable有返回值 call方法
- Runnable run方法没有返回值
- Callable返回值进行泛型，创建时候指定
- call方法抛出异常，run方法无法抛出异常
- Runnable无法获得执行中的状态，Callable可以获取执行状态，中途取消

**联系**

- Callable call方法实际的执行在Runnable的run方法中
- Runnable实例对象需要Thread包装启动
- Callable先通过FutureTask（Runnable）包装一下，再丢给Thread执行



Thread执行的Runnable接口，Callable返回值怎么来的？

- 修改Thread源码来实现
- 再想想，开闭原则
- 继承，前提 组合

# 多线程的使用场景

## 什么时候使用多线程？

- 批量处理任务
  - 向大量（100w以上）的用户发送邮件
  - 处理大批量文件
  - 处理大文件时，文件分段处理
- 实现异步
  - 快速响应用户，入浏览器请求网页、图片时
  - 自动作业处理
- 增大吞吐量，例如tomcat、数据库等服务

## 多线程应用场景实例

![image-20201018172949046](D:\code\framework-constructe-base\thread\课堂笔记-异步线程和线程池\异步线程和线程池\img\image-20201018172949046.png)

总的执行事件，取决于执行最慢的逻辑

逻辑之间无以来相关，可同时执行，则可以**应用多线程技术进行优化**

## 网关场景实例

![image-20201018173100343](D:\code\framework-constructe-base\thread\课堂笔记-异步线程和线程池\异步线程和线程池\img\image-20201018173100343.png)

# 异步线程

## Future

Future表示异步计算的结果，提供了用于检查计算是否完成、等待计算完成以及获取结果的方法

![image-20201018173157055](D:\code\framework-constructe-base\thread\课堂笔记-异步线程和线程池\异步线程和线程池\img\image-20201018173157055.png)

## Callable

Callable与Runnable的区别

- 两者都是接口，Callable定义了call方法，Runnable定义了run方法
- call方法可以抛出异常；run方法则无法抛出异常
- Callable有返回值。返回值是泛型，创建的时候传递出去，执行结果返回
- Callable执行任务的时候可以通过Future得到任务执行的状态

Callable与Runnable的联系

- Runnable实例对象需要Thread包装启动
- Callable call方法实际上在Runnable的run方法中启动
- Callable先通过FutureTask包装成Runnable，再丢给Thread包装执行



**小结：**FutureTask实际上是一个Runnable接口的实现，Callable通过FutureTask构造函数传递进来，在Runnable的run方法中执行Callable call方法，call方法返回值和异常捕获作为FutureTask成员变量，再通过get方法返回进去。

## JDK学习思路汇总

- 积累：由底层知识再到封装的工具类，足够多的“因”才能推理出“果”
- 思路：从顶层看使用，从底层看原理
- 介于：多线程编程中，不变的是**内存模型和线程通信**两个核心技术点，变化的是各种程序设计想法（算法）



### 补充：interrupte与park、wait、sleep、join

- Thread对象的native实现里有一个成员变量代表线程的**中断状态**，可以认为它是一个bool型的变量，初始为false
- Thread对象的native实现里面有一个成员代表线程是否可以阻塞的许可permit，该值只能为0或者1。初始值为0

### park/unpark实现的伪代码

```java
park(){
	if(permit>0){
        permit=0;
        return;
    }
    
    if(中断状态){
    	return;
    }
    
    阻塞当前线程 ;  //将来会被从这里唤醒
    
    if(permit>0){
        permit=0;
    }
}
```

只要permit为1或者中断状态为true，那么执行park就不会阻塞线程。park只会消耗掉permit，但不会消耗掉中断状态。

```java
unpark(Thread thread){
  if(permit<1){
  permit=1;
  if(thread处于阻塞状态){
  	唤醒线程thread
  }
  }
}
```

unpark一直会将permit置为1，如果线程阻塞，再将其唤醒。无论调用几次unpark，permit只能为1.

- 陷入阻塞

```java
    private void parkUnparkTest1() {
        LockSupport.unpark(Thread.currentThread());//置permit为1
        LockSupport.park();//消耗掉permit后，直接返回了
    }
```

- 正常返回

  ```java
      private void parkUnparkTest() {
          LockSupport.park();//因为此时permit为0且中断转态为false（默认如此），所以阻塞
      }
  ```

- 陷入阻塞

  ```java
      private void parkUnparkTest2() {
          LockSupport.unpark(Thread.currentThread());//置permit为1
          LockSupport.park();//消耗掉permit后，直接返回了
          LockSupport.park();//此时permti为0，中断状态为false，进入阻塞状态
      }
  ```

- 不会对中断状态销毁

  ```java
      private void parkUnparkTest3() {
          Thread main = Thread.currentThread();
          new Thread(() -> {
              System.out.println("子线程开始睡眠");
              try {
                  Thread.sleep(1000L);
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
              System.out.println("子线程睡醒了");
              LockSupport.unpark(main);
          }).start();
          
          LockSupport.park();//被唤醒后中断状态为true，会被唤醒
          LockSupport.park();//被唤醒后中断状态为true，会被唤醒
      }
  ```

### interrupt（）与park（）

interrupt（）实现的伪代码

```
interrupt(){
	if(中断状态==false){
		中断状态=true;
	}
	unpark(this);
}
```

- 唤醒一次park

  ```java
     private void parkUnparkTest4() {
          Thread.currentThread().interrupt();
          LockSupport.park();//消耗掉permit后，直接返回了
      }
  ```

- 多次唤醒

  ```java
      private void parkUnparkTest5() {
          Thread.currentThread().interrupt();
          LockSupport.park();//消耗掉permit后，直接返回了
          LockSupport.park();//中断状态为true，直接返回
          LockSupport.park();//同上
      }
  ```

### sleep与interrupt

sleep实现的伪代码

```
sleep(){
	if(中断状态==true){
		中断状态=false；
		throw new InterruptedException（）；
	}
	线程开始睡觉；
	if（中断状态==true）{
		中断状态=false；
		throw new InterruptedException（）；
	}
}
```

sleep会去检测中断状态，如果检测到了，那就消耗掉中断状态后，抛出中断异常。但sleep不会主动permit。

- 消耗掉中断状态

  ```java
      private void sleepInterruptTest1() {
          Thread.currentThread().interrupt();
          try {
              Thread.sleep(1000);//消耗掉中断状态，抛出异常
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
      }
  ```

- 不消耗permit

  ```java
      private void sleepInterruptTest2() {
          Thread.currentThread().interrupt();
          try {
              Thread.sleep(1000);//消耗掉中断状态，抛出异常
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
          LockSupport.park();//消耗掉permit
      }
  ```

  

wait或join效果同sleep

https://blog.csdn.net/anlian523/article/details/106752414

https://cgiirw.github.io/2018/05/27/Interrupt_Ques/

